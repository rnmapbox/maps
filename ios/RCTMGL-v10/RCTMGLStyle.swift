// DO NOT MODIFY
// THIS FILE IS AUTOGENERATED

import MapboxMaps

class RCTMGLStyle {
  var style : Style
  weak var bridge : RCTBridge?

  init(style: Style) {
    self.style = style;
  }


func fillLayer(layer: inout FillLayer, reactStyle:Dictionary<String, Any>, applyUpdater: @escaping  ((inout FillLayer)->Void)->Void, isValid: @escaping () -> Bool)
{
  guard self._hasReactStyle(reactStyle) else {
    fatalError("Invlalid style: \(reactStyle)")
  }

  let styleProps = reactStyle.keys
  for prop in styleProps {
    if (prop == "__MAPBOX_STYLESHEET__") {
      continue;
    }

    let styleValue = RCTMGLStyleValue.make(reactStyle[prop])

    if (prop == "fillSortKey") {
      self.setFillSortKey(&layer, styleValue:styleValue);
    } else if (prop == "visibility") {
      self.setFillStyleLayerVisibility(&layer, styleValue:styleValue);
    } else if (prop == "fillAntialias") {
      self.setFillAntialias(&layer, styleValue:styleValue);
    } else if (prop == "fillOpacity") {
      self.setFillOpacity(&layer, styleValue:styleValue);
    } else if (prop == "fillOpacityTransition") {
      self.setFillOpacityTransition(&layer, styleValue:styleValue);
    } else if (prop == "fillColor") {
      self.setFillColor(&layer, styleValue:styleValue);
    } else if (prop == "fillColorTransition") {
      self.setFillColorTransition(&layer, styleValue:styleValue);
    } else if (prop == "fillOutlineColor") {
      self.setFillOutlineColor(&layer, styleValue:styleValue);
    } else if (prop == "fillOutlineColorTransition") {
      self.setFillOutlineColorTransition(&layer, styleValue:styleValue);
    } else if (prop == "fillTranslate") {
      self.setFillTranslate(&layer, styleValue:styleValue);
    } else if (prop == "fillTranslateTransition") {
      self.setFillTranslateTransition(&layer, styleValue:styleValue);
    } else if (prop == "fillTranslateAnchor") {
      self.setFillTranslateAnchor(&layer, styleValue:styleValue);
    } else if (prop == "fillPattern") {
      if (!styleValue.shouldAddImage()) {
        self.setFillPattern(&layer, styleValue:styleValue);
      } else {
        let imageURI = styleValue.getImageURI()

        RCTMGLUtils.fetchImage(bridge!, url:imageURI, scale:styleValue.getImageScale(), callback:{ (error, image) in
          if let image = image {
            DispatchQueue.main.sync {
              if (isValid()) {
                try! self.style.addImage(image, id:imageURI!, stretchX: [], stretchY: []);
                applyUpdater { (layer: inout FillLayer) in
                  self.setFillPattern(&layer, styleValue:styleValue);
                }
              }
            }
          } else {
            fatalError("Error during fetchImage: \(error)")
          }
        });
      }
    } else if (prop == "fillPatternTransition") {
      self.setFillPatternTransition(&layer, styleValue:styleValue);
    } else {
      // TODO throw exception
    }
  }
}

func lineLayer(layer: inout LineLayer, reactStyle:Dictionary<String, Any>, applyUpdater: @escaping  ((inout LineLayer)->Void)->Void, isValid: @escaping () -> Bool)
{
  guard self._hasReactStyle(reactStyle) else {
    fatalError("Invlalid style: \(reactStyle)")
  }

  let styleProps = reactStyle.keys
  for prop in styleProps {
    if (prop == "__MAPBOX_STYLESHEET__") {
      continue;
    }

    let styleValue = RCTMGLStyleValue.make(reactStyle[prop])

    if (prop == "lineCap") {
      self.setLineCap(&layer, styleValue:styleValue);
    } else if (prop == "lineJoin") {
      self.setLineJoin(&layer, styleValue:styleValue);
    } else if (prop == "lineMiterLimit") {
      self.setLineMiterLimit(&layer, styleValue:styleValue);
    } else if (prop == "lineRoundLimit") {
      self.setLineRoundLimit(&layer, styleValue:styleValue);
    } else if (prop == "lineSortKey") {
      self.setLineSortKey(&layer, styleValue:styleValue);
    } else if (prop == "visibility") {
      self.setLineStyleLayerVisibility(&layer, styleValue:styleValue);
    } else if (prop == "lineOpacity") {
      self.setLineOpacity(&layer, styleValue:styleValue);
    } else if (prop == "lineOpacityTransition") {
      self.setLineOpacityTransition(&layer, styleValue:styleValue);
    } else if (prop == "lineColor") {
      self.setLineColor(&layer, styleValue:styleValue);
    } else if (prop == "lineColorTransition") {
      self.setLineColorTransition(&layer, styleValue:styleValue);
    } else if (prop == "lineTranslate") {
      self.setLineTranslate(&layer, styleValue:styleValue);
    } else if (prop == "lineTranslateTransition") {
      self.setLineTranslateTransition(&layer, styleValue:styleValue);
    } else if (prop == "lineTranslateAnchor") {
      self.setLineTranslateAnchor(&layer, styleValue:styleValue);
    } else if (prop == "lineWidth") {
      self.setLineWidth(&layer, styleValue:styleValue);
    } else if (prop == "lineWidthTransition") {
      self.setLineWidthTransition(&layer, styleValue:styleValue);
    } else if (prop == "lineGapWidth") {
      self.setLineGapWidth(&layer, styleValue:styleValue);
    } else if (prop == "lineGapWidthTransition") {
      self.setLineGapWidthTransition(&layer, styleValue:styleValue);
    } else if (prop == "lineOffset") {
      self.setLineOffset(&layer, styleValue:styleValue);
    } else if (prop == "lineOffsetTransition") {
      self.setLineOffsetTransition(&layer, styleValue:styleValue);
    } else if (prop == "lineBlur") {
      self.setLineBlur(&layer, styleValue:styleValue);
    } else if (prop == "lineBlurTransition") {
      self.setLineBlurTransition(&layer, styleValue:styleValue);
    } else if (prop == "lineDasharray") {
      self.setLineDasharray(&layer, styleValue:styleValue);
    } else if (prop == "lineDasharrayTransition") {
      self.setLineDasharrayTransition(&layer, styleValue:styleValue);
    } else if (prop == "linePattern") {
      if (!styleValue.shouldAddImage()) {
        self.setLinePattern(&layer, styleValue:styleValue);
      } else {
        let imageURI = styleValue.getImageURI()

        RCTMGLUtils.fetchImage(bridge!, url:imageURI, scale:styleValue.getImageScale(), callback:{ (error, image) in
          if let image = image {
            DispatchQueue.main.sync {
              if (isValid()) {
                try! self.style.addImage(image, id:imageURI!, stretchX: [], stretchY: []);
                applyUpdater { (layer: inout LineLayer) in
                  self.setLinePattern(&layer, styleValue:styleValue);
                }
              }
            }
          } else {
            fatalError("Error during fetchImage: \(error)")
          }
        });
      }
    } else if (prop == "linePatternTransition") {
      self.setLinePatternTransition(&layer, styleValue:styleValue);
    } else if (prop == "lineGradient") {
      self.setLineGradient(&layer, styleValue:styleValue);
    } else {
      // TODO throw exception
    }
  }
}

func symbolLayer(layer: inout SymbolLayer, reactStyle:Dictionary<String, Any>, applyUpdater: @escaping  ((inout SymbolLayer)->Void)->Void, isValid: @escaping () -> Bool)
{
  guard self._hasReactStyle(reactStyle) else {
    fatalError("Invlalid style: \(reactStyle)")
  }

  let styleProps = reactStyle.keys
  for prop in styleProps {
    if (prop == "__MAPBOX_STYLESHEET__") {
      continue;
    }

    let styleValue = RCTMGLStyleValue.make(reactStyle[prop])

    if (prop == "symbolPlacement") {
      self.setSymbolPlacement(&layer, styleValue:styleValue);
    } else if (prop == "symbolSpacing") {
      self.setSymbolSpacing(&layer, styleValue:styleValue);
    } else if (prop == "symbolAvoidEdges") {
      self.setSymbolAvoidEdges(&layer, styleValue:styleValue);
    } else if (prop == "symbolSortKey") {
      self.setSymbolSortKey(&layer, styleValue:styleValue);
    } else if (prop == "symbolZOrder") {
      self.setSymbolZOrder(&layer, styleValue:styleValue);
    } else if (prop == "iconAllowOverlap") {
      self.setIconAllowOverlap(&layer, styleValue:styleValue);
    } else if (prop == "iconIgnorePlacement") {
      self.setIconIgnorePlacement(&layer, styleValue:styleValue);
    } else if (prop == "iconOptional") {
      self.setIconOptional(&layer, styleValue:styleValue);
    } else if (prop == "iconRotationAlignment") {
      self.setIconRotationAlignment(&layer, styleValue:styleValue);
    } else if (prop == "iconSize") {
      self.setIconSize(&layer, styleValue:styleValue);
    } else if (prop == "iconTextFit") {
      self.setIconTextFit(&layer, styleValue:styleValue);
    } else if (prop == "iconTextFitPadding") {
      self.setIconTextFitPadding(&layer, styleValue:styleValue);
    } else if (prop == "iconImage") {
      if (!styleValue.shouldAddImage()) {
        self.setIconImage(&layer, styleValue:styleValue);
      } else {
        let imageURI = styleValue.getImageURI()

        RCTMGLUtils.fetchImage(bridge!, url:imageURI, scale:styleValue.getImageScale(), callback:{ (error, image) in
          if let image = image {
            DispatchQueue.main.sync {
              if (isValid()) {
                try! self.style.addImage(image, id:imageURI!, stretchX: [], stretchY: []);
                applyUpdater { (layer: inout SymbolLayer) in
                  self.setIconImage(&layer, styleValue:styleValue);
                }
              }
            }
          } else {
            fatalError("Error during fetchImage: \(error)")
          }
        });
      }
    } else if (prop == "iconRotate") {
      self.setIconRotate(&layer, styleValue:styleValue);
    } else if (prop == "iconPadding") {
      self.setIconPadding(&layer, styleValue:styleValue);
    } else if (prop == "iconKeepUpright") {
      self.setIconKeepUpright(&layer, styleValue:styleValue);
    } else if (prop == "iconOffset") {
      self.setIconOffset(&layer, styleValue:styleValue);
    } else if (prop == "iconAnchor") {
      self.setIconAnchor(&layer, styleValue:styleValue);
    } else if (prop == "iconPitchAlignment") {
      self.setIconPitchAlignment(&layer, styleValue:styleValue);
    } else if (prop == "textPitchAlignment") {
      self.setTextPitchAlignment(&layer, styleValue:styleValue);
    } else if (prop == "textRotationAlignment") {
      self.setTextRotationAlignment(&layer, styleValue:styleValue);
    } else if (prop == "textField") {
      self.setTextField(&layer, styleValue:styleValue);
    } else if (prop == "textFont") {
      self.setTextFont(&layer, styleValue:styleValue);
    } else if (prop == "textSize") {
      self.setTextSize(&layer, styleValue:styleValue);
    } else if (prop == "textMaxWidth") {
      self.setTextMaxWidth(&layer, styleValue:styleValue);
    } else if (prop == "textLineHeight") {
      self.setTextLineHeight(&layer, styleValue:styleValue);
    } else if (prop == "textLetterSpacing") {
      self.setTextLetterSpacing(&layer, styleValue:styleValue);
    } else if (prop == "textJustify") {
      self.setTextJustify(&layer, styleValue:styleValue);
    } else if (prop == "textRadialOffset") {
      self.setTextRadialOffset(&layer, styleValue:styleValue);
    } else if (prop == "textVariableAnchor") {
      self.setTextVariableAnchor(&layer, styleValue:styleValue);
    } else if (prop == "textAnchor") {
      self.setTextAnchor(&layer, styleValue:styleValue);
    } else if (prop == "textMaxAngle") {
      self.setTextMaxAngle(&layer, styleValue:styleValue);
    } else if (prop == "textWritingMode") {
      self.setTextWritingMode(&layer, styleValue:styleValue);
    } else if (prop == "textRotate") {
      self.setTextRotate(&layer, styleValue:styleValue);
    } else if (prop == "textPadding") {
      self.setTextPadding(&layer, styleValue:styleValue);
    } else if (prop == "textKeepUpright") {
      self.setTextKeepUpright(&layer, styleValue:styleValue);
    } else if (prop == "textTransform") {
      self.setTextTransform(&layer, styleValue:styleValue);
    } else if (prop == "textOffset") {
      self.setTextOffset(&layer, styleValue:styleValue);
    } else if (prop == "textAllowOverlap") {
      self.setTextAllowOverlap(&layer, styleValue:styleValue);
    } else if (prop == "textIgnorePlacement") {
      self.setTextIgnorePlacement(&layer, styleValue:styleValue);
    } else if (prop == "textOptional") {
      self.setTextOptional(&layer, styleValue:styleValue);
    } else if (prop == "visibility") {
      self.setSymbolStyleLayerVisibility(&layer, styleValue:styleValue);
    } else if (prop == "iconOpacity") {
      self.setIconOpacity(&layer, styleValue:styleValue);
    } else if (prop == "iconOpacityTransition") {
      self.setIconOpacityTransition(&layer, styleValue:styleValue);
    } else if (prop == "iconColor") {
      self.setIconColor(&layer, styleValue:styleValue);
    } else if (prop == "iconColorTransition") {
      self.setIconColorTransition(&layer, styleValue:styleValue);
    } else if (prop == "iconHaloColor") {
      self.setIconHaloColor(&layer, styleValue:styleValue);
    } else if (prop == "iconHaloColorTransition") {
      self.setIconHaloColorTransition(&layer, styleValue:styleValue);
    } else if (prop == "iconHaloWidth") {
      self.setIconHaloWidth(&layer, styleValue:styleValue);
    } else if (prop == "iconHaloWidthTransition") {
      self.setIconHaloWidthTransition(&layer, styleValue:styleValue);
    } else if (prop == "iconHaloBlur") {
      self.setIconHaloBlur(&layer, styleValue:styleValue);
    } else if (prop == "iconHaloBlurTransition") {
      self.setIconHaloBlurTransition(&layer, styleValue:styleValue);
    } else if (prop == "iconTranslate") {
      self.setIconTranslate(&layer, styleValue:styleValue);
    } else if (prop == "iconTranslateTransition") {
      self.setIconTranslateTransition(&layer, styleValue:styleValue);
    } else if (prop == "iconTranslateAnchor") {
      self.setIconTranslateAnchor(&layer, styleValue:styleValue);
    } else if (prop == "textOpacity") {
      self.setTextOpacity(&layer, styleValue:styleValue);
    } else if (prop == "textOpacityTransition") {
      self.setTextOpacityTransition(&layer, styleValue:styleValue);
    } else if (prop == "textColor") {
      self.setTextColor(&layer, styleValue:styleValue);
    } else if (prop == "textColorTransition") {
      self.setTextColorTransition(&layer, styleValue:styleValue);
    } else if (prop == "textHaloColor") {
      self.setTextHaloColor(&layer, styleValue:styleValue);
    } else if (prop == "textHaloColorTransition") {
      self.setTextHaloColorTransition(&layer, styleValue:styleValue);
    } else if (prop == "textHaloWidth") {
      self.setTextHaloWidth(&layer, styleValue:styleValue);
    } else if (prop == "textHaloWidthTransition") {
      self.setTextHaloWidthTransition(&layer, styleValue:styleValue);
    } else if (prop == "textHaloBlur") {
      self.setTextHaloBlur(&layer, styleValue:styleValue);
    } else if (prop == "textHaloBlurTransition") {
      self.setTextHaloBlurTransition(&layer, styleValue:styleValue);
    } else if (prop == "textTranslate") {
      self.setTextTranslate(&layer, styleValue:styleValue);
    } else if (prop == "textTranslateTransition") {
      self.setTextTranslateTransition(&layer, styleValue:styleValue);
    } else if (prop == "textTranslateAnchor") {
      self.setTextTranslateAnchor(&layer, styleValue:styleValue);
    } else {
      // TODO throw exception
    }
  }
}

func circleLayer(layer: inout CircleLayer, reactStyle:Dictionary<String, Any>, applyUpdater: @escaping  ((inout CircleLayer)->Void)->Void, isValid: @escaping () -> Bool)
{
  guard self._hasReactStyle(reactStyle) else {
    fatalError("Invlalid style: \(reactStyle)")
  }

  let styleProps = reactStyle.keys
  for prop in styleProps {
    if (prop == "__MAPBOX_STYLESHEET__") {
      continue;
    }

    let styleValue = RCTMGLStyleValue.make(reactStyle[prop])

    if (prop == "circleSortKey") {
      self.setCircleSortKey(&layer, styleValue:styleValue);
    } else if (prop == "visibility") {
      self.setCircleStyleLayerVisibility(&layer, styleValue:styleValue);
    } else if (prop == "circleRadius") {
      self.setCircleRadius(&layer, styleValue:styleValue);
    } else if (prop == "circleRadiusTransition") {
      self.setCircleRadiusTransition(&layer, styleValue:styleValue);
    } else if (prop == "circleColor") {
      self.setCircleColor(&layer, styleValue:styleValue);
    } else if (prop == "circleColorTransition") {
      self.setCircleColorTransition(&layer, styleValue:styleValue);
    } else if (prop == "circleBlur") {
      self.setCircleBlur(&layer, styleValue:styleValue);
    } else if (prop == "circleBlurTransition") {
      self.setCircleBlurTransition(&layer, styleValue:styleValue);
    } else if (prop == "circleOpacity") {
      self.setCircleOpacity(&layer, styleValue:styleValue);
    } else if (prop == "circleOpacityTransition") {
      self.setCircleOpacityTransition(&layer, styleValue:styleValue);
    } else if (prop == "circleTranslate") {
      self.setCircleTranslate(&layer, styleValue:styleValue);
    } else if (prop == "circleTranslateTransition") {
      self.setCircleTranslateTransition(&layer, styleValue:styleValue);
    } else if (prop == "circleTranslateAnchor") {
      self.setCircleTranslateAnchor(&layer, styleValue:styleValue);
    } else if (prop == "circlePitchScale") {
      self.setCirclePitchScale(&layer, styleValue:styleValue);
    } else if (prop == "circlePitchAlignment") {
      self.setCirclePitchAlignment(&layer, styleValue:styleValue);
    } else if (prop == "circleStrokeWidth") {
      self.setCircleStrokeWidth(&layer, styleValue:styleValue);
    } else if (prop == "circleStrokeWidthTransition") {
      self.setCircleStrokeWidthTransition(&layer, styleValue:styleValue);
    } else if (prop == "circleStrokeColor") {
      self.setCircleStrokeColor(&layer, styleValue:styleValue);
    } else if (prop == "circleStrokeColorTransition") {
      self.setCircleStrokeColorTransition(&layer, styleValue:styleValue);
    } else if (prop == "circleStrokeOpacity") {
      self.setCircleStrokeOpacity(&layer, styleValue:styleValue);
    } else if (prop == "circleStrokeOpacityTransition") {
      self.setCircleStrokeOpacityTransition(&layer, styleValue:styleValue);
    } else {
      // TODO throw exception
    }
  }
}

func heatmapLayer(layer: inout HeatmapLayer, reactStyle:Dictionary<String, Any>, applyUpdater: @escaping  ((inout HeatmapLayer)->Void)->Void, isValid: @escaping () -> Bool)
{
  guard self._hasReactStyle(reactStyle) else {
    fatalError("Invlalid style: \(reactStyle)")
  }

  let styleProps = reactStyle.keys
  for prop in styleProps {
    if (prop == "__MAPBOX_STYLESHEET__") {
      continue;
    }

    let styleValue = RCTMGLStyleValue.make(reactStyle[prop])

    if (prop == "visibility") {
      self.setHeatmapStyleLayerVisibility(&layer, styleValue:styleValue);
    } else if (prop == "heatmapRadius") {
      self.setHeatmapRadius(&layer, styleValue:styleValue);
    } else if (prop == "heatmapRadiusTransition") {
      self.setHeatmapRadiusTransition(&layer, styleValue:styleValue);
    } else if (prop == "heatmapWeight") {
      self.setHeatmapWeight(&layer, styleValue:styleValue);
    } else if (prop == "heatmapIntensity") {
      self.setHeatmapIntensity(&layer, styleValue:styleValue);
    } else if (prop == "heatmapIntensityTransition") {
      self.setHeatmapIntensityTransition(&layer, styleValue:styleValue);
    } else if (prop == "heatmapColor") {
      self.setHeatmapColor(&layer, styleValue:styleValue);
    } else if (prop == "heatmapOpacity") {
      self.setHeatmapOpacity(&layer, styleValue:styleValue);
    } else if (prop == "heatmapOpacityTransition") {
      self.setHeatmapOpacityTransition(&layer, styleValue:styleValue);
    } else {
      // TODO throw exception
    }
  }
}

func fillExtrusionLayer(layer: inout FillExtrusionLayer, reactStyle:Dictionary<String, Any>, applyUpdater: @escaping  ((inout FillExtrusionLayer)->Void)->Void, isValid: @escaping () -> Bool)
{
  guard self._hasReactStyle(reactStyle) else {
    fatalError("Invlalid style: \(reactStyle)")
  }

  let styleProps = reactStyle.keys
  for prop in styleProps {
    if (prop == "__MAPBOX_STYLESHEET__") {
      continue;
    }

    let styleValue = RCTMGLStyleValue.make(reactStyle[prop])

    if (prop == "visibility") {
      self.setFillExtrusionStyleLayerVisibility(&layer, styleValue:styleValue);
    } else if (prop == "fillExtrusionOpacity") {
      self.setFillExtrusionOpacity(&layer, styleValue:styleValue);
    } else if (prop == "fillExtrusionOpacityTransition") {
      self.setFillExtrusionOpacityTransition(&layer, styleValue:styleValue);
    } else if (prop == "fillExtrusionColor") {
      self.setFillExtrusionColor(&layer, styleValue:styleValue);
    } else if (prop == "fillExtrusionColorTransition") {
      self.setFillExtrusionColorTransition(&layer, styleValue:styleValue);
    } else if (prop == "fillExtrusionTranslate") {
      self.setFillExtrusionTranslate(&layer, styleValue:styleValue);
    } else if (prop == "fillExtrusionTranslateTransition") {
      self.setFillExtrusionTranslateTransition(&layer, styleValue:styleValue);
    } else if (prop == "fillExtrusionTranslateAnchor") {
      self.setFillExtrusionTranslateAnchor(&layer, styleValue:styleValue);
    } else if (prop == "fillExtrusionPattern") {
      if (!styleValue.shouldAddImage()) {
        self.setFillExtrusionPattern(&layer, styleValue:styleValue);
      } else {
        let imageURI = styleValue.getImageURI()

        RCTMGLUtils.fetchImage(bridge!, url:imageURI, scale:styleValue.getImageScale(), callback:{ (error, image) in
          if let image = image {
            DispatchQueue.main.sync {
              if (isValid()) {
                try! self.style.addImage(image, id:imageURI!, stretchX: [], stretchY: []);
                applyUpdater { (layer: inout FillExtrusionLayer) in
                  self.setFillExtrusionPattern(&layer, styleValue:styleValue);
                }
              }
            }
          } else {
            fatalError("Error during fetchImage: \(error)")
          }
        });
      }
    } else if (prop == "fillExtrusionPatternTransition") {
      self.setFillExtrusionPatternTransition(&layer, styleValue:styleValue);
    } else if (prop == "fillExtrusionHeight") {
      self.setFillExtrusionHeight(&layer, styleValue:styleValue);
    } else if (prop == "fillExtrusionHeightTransition") {
      self.setFillExtrusionHeightTransition(&layer, styleValue:styleValue);
    } else if (prop == "fillExtrusionBase") {
      self.setFillExtrusionBase(&layer, styleValue:styleValue);
    } else if (prop == "fillExtrusionBaseTransition") {
      self.setFillExtrusionBaseTransition(&layer, styleValue:styleValue);
    } else if (prop == "fillExtrusionVerticalGradient") {
      self.setFillExtrusionVerticalGradient(&layer, styleValue:styleValue);
    } else {
      // TODO throw exception
    }
  }
}

func rasterLayer(layer: inout RasterLayer, reactStyle:Dictionary<String, Any>, applyUpdater: @escaping  ((inout RasterLayer)->Void)->Void, isValid: @escaping () -> Bool)
{
  guard self._hasReactStyle(reactStyle) else {
    fatalError("Invlalid style: \(reactStyle)")
  }

  let styleProps = reactStyle.keys
  for prop in styleProps {
    if (prop == "__MAPBOX_STYLESHEET__") {
      continue;
    }

    let styleValue = RCTMGLStyleValue.make(reactStyle[prop])

    if (prop == "visibility") {
      self.setRasterStyleLayerVisibility(&layer, styleValue:styleValue);
    } else if (prop == "rasterOpacity") {
      self.setRasterOpacity(&layer, styleValue:styleValue);
    } else if (prop == "rasterOpacityTransition") {
      self.setRasterOpacityTransition(&layer, styleValue:styleValue);
    } else if (prop == "rasterHueRotate") {
      self.setRasterHueRotate(&layer, styleValue:styleValue);
    } else if (prop == "rasterHueRotateTransition") {
      self.setRasterHueRotateTransition(&layer, styleValue:styleValue);
    } else if (prop == "rasterBrightnessMin") {
      self.setRasterBrightnessMin(&layer, styleValue:styleValue);
    } else if (prop == "rasterBrightnessMinTransition") {
      self.setRasterBrightnessMinTransition(&layer, styleValue:styleValue);
    } else if (prop == "rasterBrightnessMax") {
      self.setRasterBrightnessMax(&layer, styleValue:styleValue);
    } else if (prop == "rasterBrightnessMaxTransition") {
      self.setRasterBrightnessMaxTransition(&layer, styleValue:styleValue);
    } else if (prop == "rasterSaturation") {
      self.setRasterSaturation(&layer, styleValue:styleValue);
    } else if (prop == "rasterSaturationTransition") {
      self.setRasterSaturationTransition(&layer, styleValue:styleValue);
    } else if (prop == "rasterContrast") {
      self.setRasterContrast(&layer, styleValue:styleValue);
    } else if (prop == "rasterContrastTransition") {
      self.setRasterContrastTransition(&layer, styleValue:styleValue);
    } else if (prop == "rasterResampling") {
      self.setRasterResampling(&layer, styleValue:styleValue);
    } else if (prop == "rasterFadeDuration") {
      self.setRasterFadeDuration(&layer, styleValue:styleValue);
    } else {
      // TODO throw exception
    }
  }
}

func hillshadeLayer(layer: inout HillshadeLayer, reactStyle:Dictionary<String, Any>, applyUpdater: @escaping  ((inout HillshadeLayer)->Void)->Void, isValid: @escaping () -> Bool)
{
  guard self._hasReactStyle(reactStyle) else {
    fatalError("Invlalid style: \(reactStyle)")
  }

  let styleProps = reactStyle.keys
  for prop in styleProps {
    if (prop == "__MAPBOX_STYLESHEET__") {
      continue;
    }

    let styleValue = RCTMGLStyleValue.make(reactStyle[prop])

    if (prop == "visibility") {
      self.setHillshadeStyleLayerVisibility(&layer, styleValue:styleValue);
    } else if (prop == "hillshadeIlluminationDirection") {
      self.setHillshadeIlluminationDirection(&layer, styleValue:styleValue);
    } else if (prop == "hillshadeIlluminationAnchor") {
      self.setHillshadeIlluminationAnchor(&layer, styleValue:styleValue);
    } else if (prop == "hillshadeExaggeration") {
      self.setHillshadeExaggeration(&layer, styleValue:styleValue);
    } else if (prop == "hillshadeExaggerationTransition") {
      self.setHillshadeExaggerationTransition(&layer, styleValue:styleValue);
    } else if (prop == "hillshadeShadowColor") {
      self.setHillshadeShadowColor(&layer, styleValue:styleValue);
    } else if (prop == "hillshadeShadowColorTransition") {
      self.setHillshadeShadowColorTransition(&layer, styleValue:styleValue);
    } else if (prop == "hillshadeHighlightColor") {
      self.setHillshadeHighlightColor(&layer, styleValue:styleValue);
    } else if (prop == "hillshadeHighlightColorTransition") {
      self.setHillshadeHighlightColorTransition(&layer, styleValue:styleValue);
    } else if (prop == "hillshadeAccentColor") {
      self.setHillshadeAccentColor(&layer, styleValue:styleValue);
    } else if (prop == "hillshadeAccentColorTransition") {
      self.setHillshadeAccentColorTransition(&layer, styleValue:styleValue);
    } else {
      // TODO throw exception
    }
  }
}

func backgroundLayer(layer: inout BackgroundLayer, reactStyle:Dictionary<String, Any>, applyUpdater: @escaping  ((inout BackgroundLayer)->Void)->Void, isValid: @escaping () -> Bool)
{
  guard self._hasReactStyle(reactStyle) else {
    fatalError("Invlalid style: \(reactStyle)")
  }

  let styleProps = reactStyle.keys
  for prop in styleProps {
    if (prop == "__MAPBOX_STYLESHEET__") {
      continue;
    }

    let styleValue = RCTMGLStyleValue.make(reactStyle[prop])

    if (prop == "visibility") {
      self.setBackgroundStyleLayerVisibility(&layer, styleValue:styleValue);
    } else if (prop == "backgroundColor") {
      self.setBackgroundColor(&layer, styleValue:styleValue);
    } else if (prop == "backgroundColorTransition") {
      self.setBackgroundColorTransition(&layer, styleValue:styleValue);
    } else if (prop == "backgroundPattern") {
      if (!styleValue.shouldAddImage()) {
        self.setBackgroundPattern(&layer, styleValue:styleValue);
      } else {
        let imageURI = styleValue.getImageURI()

        RCTMGLUtils.fetchImage(bridge!, url:imageURI, scale:styleValue.getImageScale(), callback:{ (error, image) in
          if let image = image {
            DispatchQueue.main.sync {
              if (isValid()) {
                try! self.style.addImage(image, id:imageURI!, stretchX: [], stretchY: []);
                applyUpdater { (layer: inout BackgroundLayer) in
                  self.setBackgroundPattern(&layer, styleValue:styleValue);
                }
              }
            }
          } else {
            fatalError("Error during fetchImage: \(error)")
          }
        });
      }
    } else if (prop == "backgroundPatternTransition") {
      self.setBackgroundPatternTransition(&layer, styleValue:styleValue);
    } else if (prop == "backgroundOpacity") {
      self.setBackgroundOpacity(&layer, styleValue:styleValue);
    } else if (prop == "backgroundOpacityTransition") {
      self.setBackgroundOpacityTransition(&layer, styleValue:styleValue);
    } else {
      // TODO throw exception
    }
  }
}

func skyLayer(layer: inout SkyLayer, reactStyle:Dictionary<String, Any>, applyUpdater: @escaping  ((inout SkyLayer)->Void)->Void, isValid: @escaping () -> Bool)
{
  guard self._hasReactStyle(reactStyle) else {
    fatalError("Invlalid style: \(reactStyle)")
  }

  let styleProps = reactStyle.keys
  for prop in styleProps {
    if (prop == "__MAPBOX_STYLESHEET__") {
      continue;
    }

    let styleValue = RCTMGLStyleValue.make(reactStyle[prop])

    if (prop == "visibility") {
      self.setSkyStyleLayerVisibility(&layer, styleValue:styleValue);
    } else if (prop == "skyType") {
      self.setSkyType(&layer, styleValue:styleValue);
    } else if (prop == "skyAtmosphereSun") {
      self.setSkyAtmosphereSun(&layer, styleValue:styleValue);
    } else if (prop == "skyAtmosphereSunIntensity") {
      self.setSkyAtmosphereSunIntensity(&layer, styleValue:styleValue);
    } else if (prop == "skyGradientCenter") {
      self.setSkyGradientCenter(&layer, styleValue:styleValue);
    } else if (prop == "skyGradientRadius") {
      self.setSkyGradientRadius(&layer, styleValue:styleValue);
    } else if (prop == "skyGradient") {
      self.setSkyGradient(&layer, styleValue:styleValue);
    } else if (prop == "skyAtmosphereHaloColor") {
      self.setSkyAtmosphereHaloColor(&layer, styleValue:styleValue);
    } else if (prop == "skyAtmosphereColor") {
      self.setSkyAtmosphereColor(&layer, styleValue:styleValue);
    } else if (prop == "skyOpacity") {
      self.setSkyOpacity(&layer, styleValue:styleValue);
    } else if (prop == "skyOpacityTransition") {
      self.setSkyOpacityTransition(&layer, styleValue:styleValue);
    } else {
      // TODO throw exception
    }
  }
}

func lightLayer(layer: inout Light, reactStyle:Dictionary<String, Any>, applyUpdater: @escaping  ((inout Light)->Void)->Void, isValid: @escaping () -> Bool)
{
  guard self._hasReactStyle(reactStyle) else {
    fatalError("Invlalid style: \(reactStyle)")
  }

  let styleProps = reactStyle.keys
  for prop in styleProps {
    if (prop == "__MAPBOX_STYLESHEET__") {
      continue;
    }

    let styleValue = RCTMGLStyleValue.make(reactStyle[prop])

    if (prop == "anchor") {
      self.setAnchor(&layer, styleValue:styleValue);
    } else if (prop == "position") {
      self.setPosition(&layer, styleValue:styleValue);
    } else if (prop == "positionTransition") {
      self.setPositionTransition(&layer, styleValue:styleValue);
    } else if (prop == "color") {
      self.setColor(&layer, styleValue:styleValue);
    } else if (prop == "colorTransition") {
      self.setColorTransition(&layer, styleValue:styleValue);
    } else if (prop == "intensity") {
      self.setIntensity(&layer, styleValue:styleValue);
    } else if (prop == "intensityTransition") {
      self.setIntensityTransition(&layer, styleValue:styleValue);
    } else {
      // TODO throw exception
    }
  }
}




func setFillSortKey(_ layer: inout FillLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.fillSortKey = styleValue.mglStyleValueNumber();
        
      
}

func setFillStyleLayerVisibility(_ layer: inout FillLayer, styleValue: RCTMGLStyleValue)
{
    layer.visibility = styleValue.isVisible();
}

func setFillAntialias(_ layer: inout FillLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.fillAntialias = styleValue.mglStyleValueBoolean();
        
      
}

func setFillOpacity(_ layer: inout FillLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.fillOpacity = styleValue.mglStyleValueNumber();
        
      
}

func setFillOpacityTransition(_ layer: inout FillLayer, styleValue: RCTMGLStyleValue)
{
    layer.fillOpacityTransition = styleValue.getTransition();
}

func setFillColor(_ layer: inout FillLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.fillColor = styleValue.mglStyleValueColor();
        
      
}

func setFillColorTransition(_ layer: inout FillLayer, styleValue: RCTMGLStyleValue)
{
    layer.fillColorTransition = styleValue.getTransition();
}

func setFillOutlineColor(_ layer: inout FillLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.fillOutlineColor = styleValue.mglStyleValueColor();
        
      
}

func setFillOutlineColorTransition(_ layer: inout FillLayer, styleValue: RCTMGLStyleValue)
{
    layer.fillOutlineColorTransition = styleValue.getTransition();
}

func setFillTranslate(_ layer: inout FillLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.fillTranslate = styleValue.mglStyleValueArrayNumber();
         
      
}

func setFillTranslateTransition(_ layer: inout FillLayer, styleValue: RCTMGLStyleValue)
{
    layer.fillTranslateTransition = styleValue.getTransition();
}

func setFillTranslateAnchor(_ layer: inout FillLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.fillTranslateAnchor = styleValue.mglStyleValueEnum(); 
        
      
}

func setFillPattern(_ layer: inout FillLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.fillPattern = styleValue.mglStyleValueResolvedImage();
        
      
}

func setFillPatternTransition(_ layer: inout FillLayer, styleValue: RCTMGLStyleValue)
{
    layer.fillPatternTransition = styleValue.getTransition();
}



func setLineCap(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.lineCap = styleValue.mglStyleValueEnum(); 
        
      
}

func setLineJoin(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.lineJoin = styleValue.mglStyleValueEnum(); 
        
      
}

func setLineMiterLimit(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.lineMiterLimit = styleValue.mglStyleValueNumber();
        
      
}

func setLineRoundLimit(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.lineRoundLimit = styleValue.mglStyleValueNumber();
        
      
}

func setLineSortKey(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.lineSortKey = styleValue.mglStyleValueNumber();
        
      
}

func setLineStyleLayerVisibility(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
    layer.visibility = styleValue.isVisible();
}

func setLineOpacity(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.lineOpacity = styleValue.mglStyleValueNumber();
        
      
}

func setLineOpacityTransition(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
    layer.lineOpacityTransition = styleValue.getTransition();
}

func setLineColor(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.lineColor = styleValue.mglStyleValueColor();
        
      
}

func setLineColorTransition(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
    layer.lineColorTransition = styleValue.getTransition();
}

func setLineTranslate(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.lineTranslate = styleValue.mglStyleValueArrayNumber();
         
      
}

func setLineTranslateTransition(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
    layer.lineTranslateTransition = styleValue.getTransition();
}

func setLineTranslateAnchor(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.lineTranslateAnchor = styleValue.mglStyleValueEnum(); 
        
      
}

func setLineWidth(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.lineWidth = styleValue.mglStyleValueNumber();
        
      
}

func setLineWidthTransition(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
    layer.lineWidthTransition = styleValue.getTransition();
}

func setLineGapWidth(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.lineGapWidth = styleValue.mglStyleValueNumber();
        
      
}

func setLineGapWidthTransition(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
    layer.lineGapWidthTransition = styleValue.getTransition();
}

func setLineOffset(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.lineOffset = styleValue.mglStyleValueNumber();
        
      
}

func setLineOffsetTransition(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
    layer.lineOffsetTransition = styleValue.getTransition();
}

func setLineBlur(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.lineBlur = styleValue.mglStyleValueNumber();
        
      
}

func setLineBlurTransition(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
    layer.lineBlurTransition = styleValue.getTransition();
}

func setLineDasharray(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.lineDasharray = styleValue.mglStyleValueArrayNumber();
         
      
}

func setLineDasharrayTransition(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
    layer.lineDasharrayTransition = styleValue.getTransition();
}

func setLinePattern(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.linePattern = styleValue.mglStyleValueResolvedImage();
        
      
}

func setLinePatternTransition(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
    layer.linePatternTransition = styleValue.getTransition();
}

func setLineGradient(_ layer: inout LineLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.lineGradient = styleValue.mglStyleValueColor();
        
      
}



func setSymbolPlacement(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.symbolPlacement = styleValue.mglStyleValueEnum(); 
        
      
}

func setSymbolSpacing(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.symbolSpacing = styleValue.mglStyleValueNumber();
        
      
}

func setSymbolAvoidEdges(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.symbolAvoidEdges = styleValue.mglStyleValueBoolean();
        
      
}

func setSymbolSortKey(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.symbolSortKey = styleValue.mglStyleValueNumber();
        
      
}

func setSymbolZOrder(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.symbolZOrder = styleValue.mglStyleValueEnum(); 
        
      
}

func setIconAllowOverlap(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconAllowOverlap = styleValue.mglStyleValueBoolean();
        
      
}

func setIconIgnorePlacement(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconIgnorePlacement = styleValue.mglStyleValueBoolean();
        
      
}

func setIconOptional(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconOptional = styleValue.mglStyleValueBoolean();
        
      
}

func setIconRotationAlignment(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconRotationAlignment = styleValue.mglStyleValueEnum(); 
        
      
}

func setIconSize(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconSize = styleValue.mglStyleValueNumber();
        
      
}

func setIconTextFit(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconTextFit = styleValue.mglStyleValueEnum(); 
        
      
}

func setIconTextFitPadding(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconTextFitPadding = styleValue.mglStyleValueArrayNumber();
         
      
}

func setIconImage(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconImage = styleValue.mglStyleValueResolvedImage();
        
      
}

func setIconRotate(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconRotate = styleValue.mglStyleValueNumber();
        
      
}

func setIconPadding(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconPadding = styleValue.mglStyleValueNumber();
        
      
}

func setIconKeepUpright(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconKeepUpright = styleValue.mglStyleValueBoolean();
        
      
}

func setIconOffset(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconOffset = styleValue.mglStyleValueArrayNumber();
         
      
}

func setIconAnchor(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconAnchor = styleValue.mglStyleValueEnum(); 
        
      
}

func setIconPitchAlignment(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconPitchAlignment = styleValue.mglStyleValueEnum(); 
        
      
}

func setTextPitchAlignment(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textPitchAlignment = styleValue.mglStyleValueEnum(); 
        
      
}

func setTextRotationAlignment(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textRotationAlignment = styleValue.mglStyleValueEnum(); 
        
      
}

func setTextField(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textField = styleValue.mglStyleValueFormatted();
        
      
}

func setTextFont(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textFont = styleValue.mglStyleValueArrayString();
         
      
}

func setTextSize(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textSize = styleValue.mglStyleValueNumber();
        
      
}

func setTextMaxWidth(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textMaxWidth = styleValue.mglStyleValueNumber();
        
      
}

func setTextLineHeight(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textLineHeight = styleValue.mglStyleValueNumber();
        
      
}

func setTextLetterSpacing(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textLetterSpacing = styleValue.mglStyleValueNumber();
        
      
}

func setTextJustify(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textJustify = styleValue.mglStyleValueEnum(); 
        
      
}

func setTextRadialOffset(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textRadialOffset = styleValue.mglStyleValueNumber();
        
      
}

func setTextVariableAnchor(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textVariableAnchor = styleValue.mglStyleValueArrayTextVariableAnchor();
         
      
}

func setTextAnchor(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textAnchor = styleValue.mglStyleValueEnum(); 
        
      
}

func setTextMaxAngle(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textMaxAngle = styleValue.mglStyleValueNumber();
        
      
}

func setTextWritingMode(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textWritingMode = styleValue.mglStyleValueArrayTextWritingMode();
         
      
}

func setTextRotate(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textRotate = styleValue.mglStyleValueNumber();
        
      
}

func setTextPadding(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textPadding = styleValue.mglStyleValueNumber();
        
      
}

func setTextKeepUpright(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textKeepUpright = styleValue.mglStyleValueBoolean();
        
      
}

func setTextTransform(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textTransform = styleValue.mglStyleValueEnum(); 
        
      
}

func setTextOffset(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textOffset = styleValue.mglStyleValueArrayNumber();
         
      
}

func setTextAllowOverlap(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textAllowOverlap = styleValue.mglStyleValueBoolean();
        
      
}

func setTextIgnorePlacement(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textIgnorePlacement = styleValue.mglStyleValueBoolean();
        
      
}

func setTextOptional(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textOptional = styleValue.mglStyleValueBoolean();
        
      
}

func setSymbolStyleLayerVisibility(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
    layer.visibility = styleValue.isVisible();
}

func setIconOpacity(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconOpacity = styleValue.mglStyleValueNumber();
        
      
}

func setIconOpacityTransition(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
    layer.iconOpacityTransition = styleValue.getTransition();
}

func setIconColor(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconColor = styleValue.mglStyleValueColor();
        
      
}

func setIconColorTransition(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
    layer.iconColorTransition = styleValue.getTransition();
}

func setIconHaloColor(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconHaloColor = styleValue.mglStyleValueColor();
        
      
}

func setIconHaloColorTransition(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
    layer.iconHaloColorTransition = styleValue.getTransition();
}

func setIconHaloWidth(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconHaloWidth = styleValue.mglStyleValueNumber();
        
      
}

func setIconHaloWidthTransition(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
    layer.iconHaloWidthTransition = styleValue.getTransition();
}

func setIconHaloBlur(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconHaloBlur = styleValue.mglStyleValueNumber();
        
      
}

func setIconHaloBlurTransition(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
    layer.iconHaloBlurTransition = styleValue.getTransition();
}

func setIconTranslate(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconTranslate = styleValue.mglStyleValueArrayNumber();
         
      
}

func setIconTranslateTransition(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
    layer.iconTranslateTransition = styleValue.getTransition();
}

func setIconTranslateAnchor(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.iconTranslateAnchor = styleValue.mglStyleValueEnum(); 
        
      
}

func setTextOpacity(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textOpacity = styleValue.mglStyleValueNumber();
        
      
}

func setTextOpacityTransition(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
    layer.textOpacityTransition = styleValue.getTransition();
}

func setTextColor(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textColor = styleValue.mglStyleValueColor();
        
      
}

func setTextColorTransition(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
    layer.textColorTransition = styleValue.getTransition();
}

func setTextHaloColor(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textHaloColor = styleValue.mglStyleValueColor();
        
      
}

func setTextHaloColorTransition(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
    layer.textHaloColorTransition = styleValue.getTransition();
}

func setTextHaloWidth(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textHaloWidth = styleValue.mglStyleValueNumber();
        
      
}

func setTextHaloWidthTransition(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
    layer.textHaloWidthTransition = styleValue.getTransition();
}

func setTextHaloBlur(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textHaloBlur = styleValue.mglStyleValueNumber();
        
      
}

func setTextHaloBlurTransition(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
    layer.textHaloBlurTransition = styleValue.getTransition();
}

func setTextTranslate(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textTranslate = styleValue.mglStyleValueArrayNumber();
         
      
}

func setTextTranslateTransition(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
    layer.textTranslateTransition = styleValue.getTransition();
}

func setTextTranslateAnchor(_ layer: inout SymbolLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.textTranslateAnchor = styleValue.mglStyleValueEnum(); 
        
      
}



func setCircleSortKey(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.circleSortKey = styleValue.mglStyleValueNumber();
        
      
}

func setCircleStyleLayerVisibility(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
    layer.visibility = styleValue.isVisible();
}

func setCircleRadius(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.circleRadius = styleValue.mglStyleValueNumber();
        
      
}

func setCircleRadiusTransition(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
    layer.circleRadiusTransition = styleValue.getTransition();
}

func setCircleColor(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.circleColor = styleValue.mglStyleValueColor();
        
      
}

func setCircleColorTransition(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
    layer.circleColorTransition = styleValue.getTransition();
}

func setCircleBlur(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.circleBlur = styleValue.mglStyleValueNumber();
        
      
}

func setCircleBlurTransition(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
    layer.circleBlurTransition = styleValue.getTransition();
}

func setCircleOpacity(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.circleOpacity = styleValue.mglStyleValueNumber();
        
      
}

func setCircleOpacityTransition(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
    layer.circleOpacityTransition = styleValue.getTransition();
}

func setCircleTranslate(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.circleTranslate = styleValue.mglStyleValueArrayNumber();
         
      
}

func setCircleTranslateTransition(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
    layer.circleTranslateTransition = styleValue.getTransition();
}

func setCircleTranslateAnchor(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.circleTranslateAnchor = styleValue.mglStyleValueEnum(); 
        
      
}

func setCirclePitchScale(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.circlePitchScale = styleValue.mglStyleValueEnum(); 
        
      
}

func setCirclePitchAlignment(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.circlePitchAlignment = styleValue.mglStyleValueEnum(); 
        
      
}

func setCircleStrokeWidth(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.circleStrokeWidth = styleValue.mglStyleValueNumber();
        
      
}

func setCircleStrokeWidthTransition(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
    layer.circleStrokeWidthTransition = styleValue.getTransition();
}

func setCircleStrokeColor(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.circleStrokeColor = styleValue.mglStyleValueColor();
        
      
}

func setCircleStrokeColorTransition(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
    layer.circleStrokeColorTransition = styleValue.getTransition();
}

func setCircleStrokeOpacity(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.circleStrokeOpacity = styleValue.mglStyleValueNumber();
        
      
}

func setCircleStrokeOpacityTransition(_ layer: inout CircleLayer, styleValue: RCTMGLStyleValue)
{
    layer.circleStrokeOpacityTransition = styleValue.getTransition();
}



func setHeatmapStyleLayerVisibility(_ layer: inout HeatmapLayer, styleValue: RCTMGLStyleValue)
{
    layer.visibility = styleValue.isVisible();
}

func setHeatmapRadius(_ layer: inout HeatmapLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.heatmapRadius = styleValue.mglStyleValueNumber();
        
      
}

func setHeatmapRadiusTransition(_ layer: inout HeatmapLayer, styleValue: RCTMGLStyleValue)
{
    layer.heatmapRadiusTransition = styleValue.getTransition();
}

func setHeatmapWeight(_ layer: inout HeatmapLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.heatmapWeight = styleValue.mglStyleValueNumber();
        
      
}

func setHeatmapIntensity(_ layer: inout HeatmapLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.heatmapIntensity = styleValue.mglStyleValueNumber();
        
      
}

func setHeatmapIntensityTransition(_ layer: inout HeatmapLayer, styleValue: RCTMGLStyleValue)
{
    layer.heatmapIntensityTransition = styleValue.getTransition();
}

func setHeatmapColor(_ layer: inout HeatmapLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.heatmapColor = styleValue.mglStyleValueColor();
        
      
}

func setHeatmapOpacity(_ layer: inout HeatmapLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.heatmapOpacity = styleValue.mglStyleValueNumber();
        
      
}

func setHeatmapOpacityTransition(_ layer: inout HeatmapLayer, styleValue: RCTMGLStyleValue)
{
    layer.heatmapOpacityTransition = styleValue.getTransition();
}



func setFillExtrusionStyleLayerVisibility(_ layer: inout FillExtrusionLayer, styleValue: RCTMGLStyleValue)
{
    layer.visibility = styleValue.isVisible();
}

func setFillExtrusionOpacity(_ layer: inout FillExtrusionLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.fillExtrusionOpacity = styleValue.mglStyleValueNumber();
        
      
}

func setFillExtrusionOpacityTransition(_ layer: inout FillExtrusionLayer, styleValue: RCTMGLStyleValue)
{
    layer.fillExtrusionOpacityTransition = styleValue.getTransition();
}

func setFillExtrusionColor(_ layer: inout FillExtrusionLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.fillExtrusionColor = styleValue.mglStyleValueColor();
        
      
}

func setFillExtrusionColorTransition(_ layer: inout FillExtrusionLayer, styleValue: RCTMGLStyleValue)
{
    layer.fillExtrusionColorTransition = styleValue.getTransition();
}

func setFillExtrusionTranslate(_ layer: inout FillExtrusionLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.fillExtrusionTranslate = styleValue.mglStyleValueArrayNumber();
         
      
}

func setFillExtrusionTranslateTransition(_ layer: inout FillExtrusionLayer, styleValue: RCTMGLStyleValue)
{
    layer.fillExtrusionTranslateTransition = styleValue.getTransition();
}

func setFillExtrusionTranslateAnchor(_ layer: inout FillExtrusionLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.fillExtrusionTranslateAnchor = styleValue.mglStyleValueEnum(); 
        
      
}

func setFillExtrusionPattern(_ layer: inout FillExtrusionLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.fillExtrusionPattern = styleValue.mglStyleValueResolvedImage();
        
      
}

func setFillExtrusionPatternTransition(_ layer: inout FillExtrusionLayer, styleValue: RCTMGLStyleValue)
{
    layer.fillExtrusionPatternTransition = styleValue.getTransition();
}

func setFillExtrusionHeight(_ layer: inout FillExtrusionLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.fillExtrusionHeight = styleValue.mglStyleValueNumber();
        
      
}

func setFillExtrusionHeightTransition(_ layer: inout FillExtrusionLayer, styleValue: RCTMGLStyleValue)
{
    layer.fillExtrusionHeightTransition = styleValue.getTransition();
}

func setFillExtrusionBase(_ layer: inout FillExtrusionLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.fillExtrusionBase = styleValue.mglStyleValueNumber();
        
      
}

func setFillExtrusionBaseTransition(_ layer: inout FillExtrusionLayer, styleValue: RCTMGLStyleValue)
{
    layer.fillExtrusionBaseTransition = styleValue.getTransition();
}

func setFillExtrusionVerticalGradient(_ layer: inout FillExtrusionLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.fillExtrusionVerticalGradient = styleValue.mglStyleValueBoolean();
        
      
}



func setRasterStyleLayerVisibility(_ layer: inout RasterLayer, styleValue: RCTMGLStyleValue)
{
    layer.visibility = styleValue.isVisible();
}

func setRasterOpacity(_ layer: inout RasterLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.rasterOpacity = styleValue.mglStyleValueNumber();
        
      
}

func setRasterOpacityTransition(_ layer: inout RasterLayer, styleValue: RCTMGLStyleValue)
{
    layer.rasterOpacityTransition = styleValue.getTransition();
}

func setRasterHueRotate(_ layer: inout RasterLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.rasterHueRotate = styleValue.mglStyleValueNumber();
        
      
}

func setRasterHueRotateTransition(_ layer: inout RasterLayer, styleValue: RCTMGLStyleValue)
{
    layer.rasterHueRotateTransition = styleValue.getTransition();
}

func setRasterBrightnessMin(_ layer: inout RasterLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.rasterBrightnessMin = styleValue.mglStyleValueNumber();
        
      
}

func setRasterBrightnessMinTransition(_ layer: inout RasterLayer, styleValue: RCTMGLStyleValue)
{
    layer.rasterBrightnessMinTransition = styleValue.getTransition();
}

func setRasterBrightnessMax(_ layer: inout RasterLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.rasterBrightnessMax = styleValue.mglStyleValueNumber();
        
      
}

func setRasterBrightnessMaxTransition(_ layer: inout RasterLayer, styleValue: RCTMGLStyleValue)
{
    layer.rasterBrightnessMaxTransition = styleValue.getTransition();
}

func setRasterSaturation(_ layer: inout RasterLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.rasterSaturation = styleValue.mglStyleValueNumber();
        
      
}

func setRasterSaturationTransition(_ layer: inout RasterLayer, styleValue: RCTMGLStyleValue)
{
    layer.rasterSaturationTransition = styleValue.getTransition();
}

func setRasterContrast(_ layer: inout RasterLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.rasterContrast = styleValue.mglStyleValueNumber();
        
      
}

func setRasterContrastTransition(_ layer: inout RasterLayer, styleValue: RCTMGLStyleValue)
{
    layer.rasterContrastTransition = styleValue.getTransition();
}

func setRasterResampling(_ layer: inout RasterLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.rasterResampling = styleValue.mglStyleValueEnum(); 
        
      
}

func setRasterFadeDuration(_ layer: inout RasterLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.rasterFadeDuration = styleValue.mglStyleValueNumber();
        
      
}



func setHillshadeStyleLayerVisibility(_ layer: inout HillshadeLayer, styleValue: RCTMGLStyleValue)
{
    layer.visibility = styleValue.isVisible();
}

func setHillshadeIlluminationDirection(_ layer: inout HillshadeLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.hillshadeIlluminationDirection = styleValue.mglStyleValueNumber();
        
      
}

func setHillshadeIlluminationAnchor(_ layer: inout HillshadeLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.hillshadeIlluminationAnchor = styleValue.mglStyleValueEnum(); 
        
      
}

func setHillshadeExaggeration(_ layer: inout HillshadeLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.hillshadeExaggeration = styleValue.mglStyleValueNumber();
        
      
}

func setHillshadeExaggerationTransition(_ layer: inout HillshadeLayer, styleValue: RCTMGLStyleValue)
{
    layer.hillshadeExaggerationTransition = styleValue.getTransition();
}

func setHillshadeShadowColor(_ layer: inout HillshadeLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.hillshadeShadowColor = styleValue.mglStyleValueColor();
        
      
}

func setHillshadeShadowColorTransition(_ layer: inout HillshadeLayer, styleValue: RCTMGLStyleValue)
{
    layer.hillshadeShadowColorTransition = styleValue.getTransition();
}

func setHillshadeHighlightColor(_ layer: inout HillshadeLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.hillshadeHighlightColor = styleValue.mglStyleValueColor();
        
      
}

func setHillshadeHighlightColorTransition(_ layer: inout HillshadeLayer, styleValue: RCTMGLStyleValue)
{
    layer.hillshadeHighlightColorTransition = styleValue.getTransition();
}

func setHillshadeAccentColor(_ layer: inout HillshadeLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.hillshadeAccentColor = styleValue.mglStyleValueColor();
        
      
}

func setHillshadeAccentColorTransition(_ layer: inout HillshadeLayer, styleValue: RCTMGLStyleValue)
{
    layer.hillshadeAccentColorTransition = styleValue.getTransition();
}



func setBackgroundStyleLayerVisibility(_ layer: inout BackgroundLayer, styleValue: RCTMGLStyleValue)
{
    layer.visibility = styleValue.isVisible();
}

func setBackgroundColor(_ layer: inout BackgroundLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.backgroundColor = styleValue.mglStyleValueColor();
        
      
}

func setBackgroundColorTransition(_ layer: inout BackgroundLayer, styleValue: RCTMGLStyleValue)
{
    layer.backgroundColorTransition = styleValue.getTransition();
}

func setBackgroundPattern(_ layer: inout BackgroundLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.backgroundPattern = styleValue.mglStyleValueResolvedImage();
        
      
}

func setBackgroundPatternTransition(_ layer: inout BackgroundLayer, styleValue: RCTMGLStyleValue)
{
    layer.backgroundPatternTransition = styleValue.getTransition();
}

func setBackgroundOpacity(_ layer: inout BackgroundLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.backgroundOpacity = styleValue.mglStyleValueNumber();
        
      
}

func setBackgroundOpacityTransition(_ layer: inout BackgroundLayer, styleValue: RCTMGLStyleValue)
{
    layer.backgroundOpacityTransition = styleValue.getTransition();
}



func setSkyStyleLayerVisibility(_ layer: inout SkyLayer, styleValue: RCTMGLStyleValue)
{
    layer.visibility = styleValue.isVisible();
}

func setSkyType(_ layer: inout SkyLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.skyType = styleValue.mglStyleValueEnum(); 
        
      
}

func setSkyAtmosphereSun(_ layer: inout SkyLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.skyAtmosphereSun = styleValue.mglStyleValueArrayNumber();
         
      
}

func setSkyAtmosphereSunIntensity(_ layer: inout SkyLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.skyAtmosphereSunIntensity = styleValue.mglStyleValueNumber();
        
      
}

func setSkyGradientCenter(_ layer: inout SkyLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.skyGradientCenter = styleValue.mglStyleValueArrayNumber();
         
      
}

func setSkyGradientRadius(_ layer: inout SkyLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.skyGradientRadius = styleValue.mglStyleValueNumber();
        
      
}

func setSkyGradient(_ layer: inout SkyLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.skyGradient = styleValue.mglStyleValueColor();
        
      
}

func setSkyAtmosphereHaloColor(_ layer: inout SkyLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.skyAtmosphereHaloColor = styleValue.mglStyleValueColor();
        
      
}

func setSkyAtmosphereColor(_ layer: inout SkyLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.skyAtmosphereColor = styleValue.mglStyleValueColor();
        
      
}

func setSkyOpacity(_ layer: inout SkyLayer, styleValue: RCTMGLStyleValue)
{
      
        
          layer.skyOpacity = styleValue.mglStyleValueNumber();
        
      
}

func setSkyOpacityTransition(_ layer: inout SkyLayer, styleValue: RCTMGLStyleValue)
{
    layer.skyOpacityTransition = styleValue.getTransition();
}



func setAnchor(_ layer: inout Light, styleValue: RCTMGLStyleValue)
{
      
        
          layer.anchor = styleValue.mglStyleValueAnchorRaw(); 
        
      
}

func setPosition(_ layer: inout Light, styleValue: RCTMGLStyleValue)
{
    layer.position = styleValue.getSphericalPosition();
}

func setPositionTransition(_ layer: inout Light, styleValue: RCTMGLStyleValue)
{
    layer.positionTransition = styleValue.getTransition();
}

func setColor(_ layer: inout Light, styleValue: RCTMGLStyleValue)
{
      
        
          layer.color = styleValue.mglStyleValueColorRaw();
        
      
}

func setColorTransition(_ layer: inout Light, styleValue: RCTMGLStyleValue)
{
    layer.colorTransition = styleValue.getTransition();
}

func setIntensity(_ layer: inout Light, styleValue: RCTMGLStyleValue)
{
      
        
          layer.intensity = styleValue.mglStyleValueNumberRaw();
        
      
}

func setIntensityTransition(_ layer: inout Light, styleValue: RCTMGLStyleValue)
{
    layer.intensityTransition = styleValue.getTransition();
}



func _hasReactStyle(_ reactStyle: Dictionary<String, Any>) -> Bool
{
  return reactStyle != nil && reactStyle.keys.count > 0;
}

}
